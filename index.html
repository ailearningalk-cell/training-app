<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Training & Development, DPDC</title>
  <style>
    :root{
      --bg:#0f172a;         /* slate-900 */
      --fg:#e2e8f0;         /* slate-200 */
      --brand:#60a5fa;      /* blue-400 */
      --accent:#a78bfa;     /* violet-400 */
    }
    *{box-sizing:border-box; margin:0; padding:0}
    html,body{height:100%;}
    body{
      margin:0; font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
      color:var(--fg); background:var(--bg);
      display:grid; place-items:center; overflow:hidden;
    }

    /* ---------- Network Background ---------- */
    .bg{
      position:fixed; inset:0; pointer-events:none; overflow:hidden;
      background: linear-gradient(135deg, #0b1220 0%, #0f172a 50%, #0b1220 100%);
    }
    
    /* Canvas for animated connections */
    #network-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    /* ---------- Foreground Container ---------- */
    .container { 
      text-align: center; 
      color: #fff; 
      position: relative; 
      z-index: 2;
    }

    .logo {
      width: 120px; height: 120px; margin: 0 auto 20px;
      display: flex; justify-content: center; align-items: center; overflow: hidden;
      box-shadow: 0 0 25px rgba(96,165,250,0.45);   /* faint glow */
      border-radius: 50%;  /* keeps the glow circular */
      animation: pop 1.2s ease forwards;
    }
    .logo img {
      width: 100%; height: 100%; object-fit: contain;
    }

    h1 { 
      font-size: 24px; 
      margin-bottom: 10px; 
      opacity: 0; 
      animation: fadeInUp 1s ease 0.8s forwards;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }
    p { 
      font-size: 14px; 
      opacity: 0; 
      animation: fadeInUp 1s ease 1.4s forwards;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }

    .progress-bar { 
      margin: 30px auto 0; 
      width: 220px; 
      height: 6px; 
      background: rgba(255,255,255,0.25); 
      border-radius: 999px; 
      overflow: hidden; 
    }
    .progress { 
      height: 100%; 
      width: 0%; 
      background: linear-gradient(90deg, var(--brand), var(--accent)); 
      animation: load 4s ease forwards;
    }

    @keyframes pop {
      0% { transform: scale(0.5); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    @keyframes fadeInUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    @keyframes load {
      0% { width: 0%; }
      100% { width: 100%; }
    }

    /* Particles */
    #fx{ position:fixed; inset:0; z-index:1; pointer-events:none; opacity:.35 }
  </style>
</head>
<body>
  <div class="bg" aria-hidden="true"></div>
  <canvas id="network-canvas"></canvas>
  <canvas id="fx" width="1920" height="1080" aria-hidden="true"></canvas>

  <div class="container">
    <div class="logo">
      <img src="https://ailearningalk-cell.github.io/training-app/icons/logo.png" alt="App Logo">
    </div>
    <h1>Training & Development, DPDC</h1>
    <p>Empowering Learning, Inspiring Growth</p>
    <div class="progress-bar"><div class="progress"></div></div>
  </div>

  <script>
    // Redirect after 4 seconds to home.html
    setTimeout(() => {
      window.location.replace("home.html");
    }, 4000);

    // Lightweight particles - continuous animation
    const cv = document.getElementById('fx');
    const ctx = cv.getContext('2d');
    const pr = Math.min(2, window.devicePixelRatio || 1);
    let W,H,parts=[];
    function resize(){
      W=cv.width=Math.floor(innerWidth*pr);
      H=cv.height=Math.floor(innerHeight*pr);
      parts=Array.from({length:40},()=>({
        x:Math.random()*W,y:Math.random()*H,r:1+Math.random()*2*pr,
        vx:(-.2+Math.random()*.4)*pr,vy:(-.2+Math.random()*.4)*pr
      }));
    }
    function step(){
      ctx.clearRect(0,0,W,H);
      ctx.globalAlpha=0.8;ctx.lineWidth=1*pr;
      parts.forEach(pt=>{
        pt.x+=pt.vx; pt.y+=pt.vy;
        if(pt.x<0||pt.x>W)pt.vx*=-1;
        if(pt.y<0||pt.y>H)pt.vy*=-1;
        ctx.beginPath(); ctx.arc(pt.x,pt.y,pt.r,0,Math.PI*2);
        ctx.strokeStyle='rgba(96,165,250,.45)'; ctx.stroke();
      });
      requestAnimationFrame(step);
    }
    addEventListener('resize',resize,{passive:true}); resize(); step();

    // Network background animation - continuous animation
    const networkCanvas = document.getElementById('network-canvas');
    const networkCtx = networkCanvas.getContext('2d');
    let nodes = [];
    
    function setupNetwork() {
      networkCanvas.width = window.innerWidth;
      networkCanvas.height = window.innerHeight;
      
      // Create nodes
      nodes = [];
      const nodeCount = 25;
      for (let i = 0; i < nodeCount; i++) {
        nodes.push({
          x: Math.random() * networkCanvas.width,
          y: Math.random() * networkCanvas.height,
          radius: Math.random() * 2 + 1,
          vx: (Math.random() - 0.5) * 0.4,
          vy: (Math.random() - 0.5) * 0.4
        });
      }
      
      animateNetwork();
    }
    
    function animateNetwork() {
      networkCtx.clearRect(0, 0, networkCanvas.width, networkCanvas.height);
      
      // Update and draw nodes
      nodes.forEach(node => {
        node.x += node.vx;
        node.y += node.vy;
        
        if (node.x < 0 || node.x > networkCanvas.width) node.vx *= -1;
        if (node.y < 0 || node.y > networkCanvas.height) node.vy *= -1;
        
        networkCtx.beginPath();
        networkCtx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
        networkCtx.fillStyle = `rgba(96, 165, 250, ${0.4 + Math.random() * 0.3})`;
        networkCtx.fill();
      });
      
      // Draw connections
      nodes.forEach((node, i) => {
        nodes.forEach((otherNode, j) => {
          if (i !== j) {
            const dx = node.x - otherNode.x;
            const dy = node.y - otherNode.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 150) {
              const opacity = 1 - dist / 150;
              networkCtx.beginPath();
              networkCtx.moveTo(node.x, node.y);
              networkCtx.lineTo(otherNode.x, otherNode.y);
              networkCtx.strokeStyle = `rgba(96, 165, 250, ${opacity * 0.15})`;
              networkCtx.lineWidth = 0.5;
              networkCtx.stroke();
            }
          }
        });
      });
      
      requestAnimationFrame(animateNetwork);
    }
    
    window.addEventListener('resize', () => {
      setupNetwork();
    });
    
    setupNetwork();
  </script>
</body>
</html>
